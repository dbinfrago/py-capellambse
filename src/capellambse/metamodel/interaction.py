# SPDX-FileCopyrightText: Copyright DB InfraGO AG
# SPDX-License-Identifier: Apache-2.0
from __future__ import annotations

import enum
import typing as t
import warnings

import capellambse.model as m
from capellambse.model import _descriptors, _pods

from . import behavior, capellacore, fa
from . import namespaces as ns

NS = ns.INTERACTION


@m.stringy_enum
@enum.unique
class InteractionOperatorKind(enum.Enum):
    ALT = "ALT"
    OPT = "OPT"
    PAR = "PAR"
    LOOP = "LOOP"
    CRITICAL = "CRITICAL"
    NEG = "NEG"
    ASSERT = "ASSERT"
    STRICT = "STRICT"
    SEQ = "SEQ"
    IGNORE = "IGNORE"
    CONSIDER = "CONSIDER"
    UNSET = "UNSET"


@m.stringy_enum
@enum.unique
class MessageKind(enum.Enum):
    """Identifies the type of message.

    This concept is similar to UML ``MessageSort``.
    """

    UNSET = "UNSET"
    """The message kind is not specified."""
    ASYNCHRONOUS_CALL = "ASYNCHRONOUS_CALL"
    """The message was generated by an asynchronous call to an operation.

    Equivalent to UML ``MessageSort::asynchCall``.
    """
    SYNCHRONOUS_CALL = "SYNCHRONOUS_CALL"
    """The message was generated by a synchronous call to an operation.

    Equivalent to UML ``MessageSort::synchCall``.
    """
    REPLY = "REPLY"
    """The message is a reply message to an operation call.

    Equivalent to UML ``MessageSort::reply``.
    """
    DELETE = "DELETE"
    """The message designates the termination of another lifeline.

    Equivalent to UML ``MessageSort::deleteMessage``.
    """
    CREATE = "CREATE"
    """The message designates the creation of an instance role."""
    TIMER = "TIMER"


@m.stringy_enum
@enum.unique
class ScenarioKind(enum.Enum):
    INTERFACE = "INTERFACE"
    DATA_FLOW = "DATA_FLOW"
    INTERACTION = "INTERACTION"
    FUNCTIONAL = "FUNCTIONAL"
    UNSET = "UNSET"


class SequenceMessage(capellacore.NamedElement):
    """A sequence message."""

    kind = _pods.EnumPOD("kind", MessageKind)
    exchange_context = _descriptors.Association["capellacore.Constraint"](
        (ns.CAPELLACORE, "Constraint"), "exchangeContext"
    )
    sending_end = _descriptors.Association["MessageEnd"]((NS, "MessageEnd"), "sendingEnd")
    receiving_end = _descriptors.Association["MessageEnd"](
        (NS, "MessageEnd"), "receivingEnd"
    )
    exchanged_items = _descriptors.Association["information.ExchangeItem"](
        (ns.INFORMATION, "ExchangeItem"), "exchangedItems"
    )
    valuations = _descriptors.Containment["SequenceMessageValuation"](
        "ownedSequenceMessageValuations", (NS, "SequenceMessageValuation")
    )

    if not t.TYPE_CHECKING:
        source = _descriptors.DeprecatedAccessor("sending_end")
        target = _descriptors.DeprecatedAccessor("receiving_end")


class Scenario(capellacore.Namespace, behavior.AbstractBehavior):
    kind = _pods.EnumPOD("kind", ScenarioKind)
    is_merged = _pods.BoolPOD("merged")

    precondition = _descriptors.Single["capellacore.Constraint"](
        _descriptors.Association((ns.CAPELLACORE, "Constraint"), "preCondition")
    )
    postcondition = _descriptors.Single["capellacore.Constraint"](
        _descriptors.Association((ns.CAPELLACORE, "Constraint"), "postCondition")
    )
    instance_roles = _descriptors.Containment["InstanceRole"](
        "ownedInstanceRoles", (NS, "InstanceRole")
    )
    messages = _descriptors.Containment["SequenceMessage"](
        "ownedMessages", (NS, "SequenceMessage")
    )
    fragments = _descriptors.Containment["InteractionFragment"](
        "ownedInteractionFragments",
        (NS, "InteractionFragment"),
        legacy_by_type=True,
    )
    time_lapses = _descriptors.Containment["TimeLapse"](
        "ownedTimeLapses", (NS, "TimeLapse"), legacy_by_type=True
    )
    events = _descriptors.Containment["Event"](
        "ownedEvents", (NS, "Event"), legacy_by_type=True
    )
    formal_gates = _descriptors.Containment["Gate"]("ownedFormalGates", (NS, "Gate"))
    scenario_realizations = _descriptors.Containment["ScenarioRealization"](
        "ownedScenarioRealization", (NS, "ScenarioRealization")
    )
    realized_scenarios = _descriptors.Allocation["Scenario"](
        "ownedScenarioRealization",
        (NS, "ScenarioRealization"),
        (NS, "Scenario"),
        attr="targetElement",
        backattr="sourceElement",
    )
    realizing_scenarios = _descriptors.Backref["Scenario"](
        (NS, "Scenario"), "realized_scenarios"
    )
    constraint_durations = _descriptors.Containment["ConstraintDuration"](
        "ownedConstraintDurations", (NS, "ConstraintDuration")
    )

    @property
    def related_functions(self) -> m.ElementList[fa.AbstractFunction]:
        return self.fragments.map("function")


class InteractionFragment(capellacore.NamedElement, abstract=True):
    covered_instance_roles = _descriptors.Association["InstanceRole"](
        (NS, "InstanceRole"), "coveredInstanceRoles", legacy_by_type=True
    )

    if not t.TYPE_CHECKING:
        covered = _descriptors.DeprecatedAccessor("covered_instance_roles")


class AbstractEnd(InteractionFragment, abstract=True):
    event = _descriptors.Single["Event"](_descriptors.Association((NS, "Event"), "event"))


class MessageEnd(AbstractEnd):
    pass


class TimeLapse(capellacore.NamedElement, abstract=True):
    start = _descriptors.Single["InteractionFragment"](
        _descriptors.Association((NS, "InteractionFragment"), "start")
    )
    finish = _descriptors.Single["InteractionFragment"](
        _descriptors.Association((NS, "InteractionFragment"), "finish")
    )


class Execution(TimeLapse):
    pass


class ExecutionEnd(AbstractEnd):
    pass


class Event(capellacore.NamedElement, behavior.AbstractEvent, abstract=True):
    pass


class CreationEvent(Event):
    pass


class DestructionEvent(Event):
    pass


class ExecutionEvent(Event):
    pass


class InstanceRole(capellacore.NamedElement):
    represented_instance = _descriptors.Single["information.AbstractInstance"](
        _descriptors.Association(
            (ns.INFORMATION, "AbstractInstance"), "representedInstance"
        )
    )

    if not t.TYPE_CHECKING:
        instance = _descriptors.DeprecatedAccessor("represented_instance")


class _EventOperation(Event):
    # TODO delete this class when removing deprecated features
    operation = _descriptors.Association["information.AbstractEventOperation"](
        (ns.INFORMATION, "AbstractEventOperation"), "operation"
    )


class EventReceiptOperation(_EventOperation):
    operation = _descriptors.Association["information.AbstractEventOperation"](
        (ns.INFORMATION, "AbstractEventOperation"), "operation"
    )


class EventSentOperation(_EventOperation):
    operation = _descriptors.Association["information.AbstractEventOperation"](
        (ns.INFORMATION, "AbstractEventOperation"), "operation"
    )


class MergeLink(capellacore.Trace):
    pass


class RefinementLink(capellacore.Trace):
    pass


class AbstractCapabilityRealization(capellacore.Allocation):
    pass


class AbstractCapability(
    capellacore.Structure,
    capellacore.InvolverElement,
    fa.AbstractFunctionalChainContainer,
    abstract=True,
):
    precondition = _descriptors.Single["capellacore.Constraint"](
        _descriptors.Association((ns.CAPELLACORE, "Constraint"), "preCondition")
    )
    postcondition = _descriptors.Single["capellacore.Constraint"](
        _descriptors.Association((ns.CAPELLACORE, "Constraint"), "postCondition")
    )
    scenarios = _descriptors.Containment["Scenario"]("ownedScenarios", (NS, "Scenario"))
    extends = _descriptors.Containment["AbstractCapabilityExtend"](
        "extends", (NS, "AbstractCapabilityExtend")
    )
    extended_by = _descriptors.Backref["AbstractCapabilityExtend"](
        (NS, "AbstractCapabilityExtend"), "target"
    )
    extension_points = _descriptors.Containment["AbstractCapabilityExtensionPoint"](
        "abstractCapabilityExtensionPoints",
        (NS, "AbstractCapabilityExtensionPoint"),
    )
    generalizations = _descriptors.Containment["AbstractCapabilityGeneralization"](
        "superGeneralizations", (NS, "AbstractCapabilityGeneralization")
    )
    generalized_by = _descriptors.Backref["AbstractCapability"](
        (NS, "AbstractCapability"), "target"
    )
    includes = _descriptors.Containment["AbstractCapabilityInclude"](
        "includes", (NS, "AbstractCapabilityInclude")
    )
    included_by = _descriptors.Backref["AbstractCapabilityInclude"](
        (NS, "AbstractCapabilityInclude"), "included"
    )
    chain_involvements = _descriptors.Containment[
        "FunctionalChainAbstractCapabilityInvolvement"
    ](
        "ownedFunctionalChainAbstractCapabilityInvolvements",
        (NS, "FunctionalChainAbstractCapabilityInvolvement"),
    )
    involved_chains = _descriptors.Allocation["fa.FunctionalChain"](
        "ownedFunctionalChainAbstractCapabilityInvolvements",
        (NS, "FunctionalChainAbstractCapabilityInvolvement"),
        (ns.FA, "AbstractFunction"),
        attr="involved",
    )
    function_involvements = _descriptors.Containment[
        "AbstractFunctionAbstractCapabilityInvolvement"
    ](
        "ownedAbstractFunctionAbstractCapabilityInvolvements",
        (NS, "AbstractFunctionAbstractCapabilityInvolvement"),
    )
    involved_functions = _descriptors.Allocation["fa.AbstractFunction"](
        "ownedAbstractFunctionAbstractCapabilityInvolvements",
        (NS, "AbstractFunctionAbstractCapabilityInvolvement"),
        (ns.FA, "AbstractFunction"),
        attr="involved",
    )
    available_in_states = _descriptors.Association["capellacommon.State"](
        (ns.CAPELLACOMMON, "State"), "availableInStates"
    )
    capability_realizations = _descriptors.Containment["AbstractCapabilityRealization"](
        "ownedAbstractCapabilityRealizations",
        (NS, "AbstractCapabilityRealization"),
    )
    realized_capabilities = _descriptors.Allocation["AbstractCapability"](
        "ownedAbstractCapabilityRealizations",
        (NS, "AbstractCapabilityRealization"),
        (NS, "AbstractCapability"),
        attr="targetElement",
    )
    realizing_capabilities = _descriptors.Backref["AbstractCapability"](
        (NS, "AbstractCapability"), "realized_capabilities"
    )

    if not t.TYPE_CHECKING:
        generalizes = _descriptors.DeprecatedAccessor("generalizations")
        states = _descriptors.DeprecatedAccessor("available_in_states")


class AbstractCapabilityExtend(capellacore.Relationship):
    _xmltag = "extends"

    source = _descriptors.Alias["m.ModelElement"]("parent")
    extended = _descriptors.Single["AbstractCapability"](
        _descriptors.Association((NS, "AbstractCapability"), "extended")
    )
    target = _descriptors.Alias["AbstractCapability"]("extended")
    extension_location = _descriptors.Single["AbstractCapabilityExtensionPoint"](
        _descriptors.Association(
            (NS, "AbstractCapabilityExtensionPoint"), "extensionLocation"
        )
    )


class AbstractCapabilityExtensionPoint(capellacore.NamedRelationship):
    extend_links = _descriptors.Association["AbstractCapabilityExtend"](
        (NS, "AbstractCapabilityExtend"), "extendLinks"
    )


class AbstractCapabilityGeneralization(capellacore.Relationship):
    _xmltag = "superGeneralizations"

    source = _descriptors.Alias["m.ModelElement"]("parent")
    super = _descriptors.Single["AbstractCapability"](
        _descriptors.Association((NS, "AbstractCapability"), "super")
    )
    target = _descriptors.Alias["AbstractCapability"]("super")


class AbstractCapabilityInclude(capellacore.Relationship):
    _xmltag = "includes"

    source = _descriptors.Alias["m.ModelElement"]("parent")
    included = _descriptors.Single["AbstractCapability"](
        _descriptors.Association((NS, "AbstractCapability"), "included")
    )
    target = _descriptors.Alias["AbstractCapability"]("included")


class InteractionState(InteractionFragment):
    state = _descriptors.Single["capellacommon.AbstractState"](
        _descriptors.Association(
            (ns.CAPELLACOMMON, "AbstractState"), "relatedAbstractState"
        )
    )
    function = _descriptors.Single["fa.AbstractFunction"](
        _descriptors.Association((ns.FA, "AbstractFunction"), "relatedAbstractFunction")
    )


class AbstractFragment(TimeLapse, abstract=True):
    gates = _descriptors.Containment["Gate"]("ownedGates", (NS, "Gate"))


class InteractionUse(AbstractFragment):
    referenced_scenario = _descriptors.Single["Scenario"](
        _descriptors.Association((NS, "Scenario"), "referencedScenario")
    )


class CombinedFragment(AbstractFragment):
    operator = _pods.EnumPOD("operator", InteractionOperatorKind)
    operands = _descriptors.Association["InteractionOperand"](
        (NS, "InteractionOperand"), "referencedOperands"
    )


class Gate(MessageEnd):
    pass


class InteractionOperand(InteractionFragment):
    fragments = _descriptors.Association["InteractionFragment"](
        (NS, "InteractionFragment"), "referencedInteractionFragments"
    )
    guard = _descriptors.Single["capellacore.Constraint"](
        _descriptors.Association((ns.CAPELLACORE, "Constraint"), "guard")
    )


class FragmentEnd(InteractionFragment):
    pass


class FunctionalChainAbstractCapabilityInvolvement(capellacore.Involvement):
    pass


class AbstractFunctionAbstractCapabilityInvolvement(capellacore.Involvement):
    pass


class ScenarioRealization(capellacore.Allocation):
    pass


class StateFragment(TimeLapse):
    state = _descriptors.Single["capellacommon.AbstractState"](
        _descriptors.Association(
            (ns.CAPELLACOMMON, "AbstractState"), "relatedAbstractState"
        )
    )
    function = _descriptors.Single["fa.AbstractFunction"](
        _descriptors.Association((ns.FA, "AbstractFunction"), "relatedAbstractFunction")
    )


class ArmTimerEvent(Event):
    pass


class CancelTimerEvent(Event):
    pass


class ConstraintDuration(capellacore.NamedElement):
    duration = _pods.StringPOD("duration")
    start = _descriptors.Single["InteractionFragment"](
        _descriptors.Association((NS, "InteractionFragment"), "start")
    )
    finish = _descriptors.Single["InteractionFragment"](
        _descriptors.Association((NS, "InteractionFragment"), "finish")
    )


class SequenceMessageValuation(capellacore.CapellaElement):
    element = _descriptors.Single["information.ExchangeItemElement"](
        _descriptors.Association(
            (ns.INFORMATION, "ExchangeItemElement"), "exchangeItemElement"
        )
    )
    value = _descriptors.Single["modellingcore.ValueSpecification"](
        _descriptors.Association((ns.MODELLINGCORE, "ValueSpecification"), "value")
    )


if not t.TYPE_CHECKING:

    def __getattr__(name):
        if name == "Exchange":
            warnings.warn(
                "The Exchange class has been removed, use capellacore.Relationship instead",
                DeprecationWarning,
                stacklevel=2,
            )
            return capellacore.Relationship

        if name == "AbstractInvolvement":
            warnings.warn(
                "interaction.AbstractInvolvement has been moved to capellacore.Involvement",
                DeprecationWarning,
                stacklevel=2,
            )
            return capellacore.Involvement

        if name == "EventOperation":
            warnings.warn(
                (
                    "EventOperation has been removed,"
                    " use EventSentOperation/EventReceiptOperation directly"
                    " or another common super class instead"
                ),
                DeprecationWarning,
                stacklevel=2,
            )
            return _EventOperation

        raise AttributeError(name)


from . import capellacommon, information, modellingcore  # noqa: F401
